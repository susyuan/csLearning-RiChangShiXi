# 日常实习-JVM面试题

8.描述一下JVM？我就说了一下Java内存区域。
9.问我了不了解 GC，说一下相关算法？我就记起来标记复制和标记整理了，标记复制还说成了标记清除哈哈。

5.JVM垃圾回收（感觉没说全，我这种垃圾就该被回收呜呜呜）

8.HotSpot VM 的实现，Partial GC和Full GC

9.双亲委派模型

10.java内存模型

# 基础

## 讲一下JVM（聊一下你对JVM的理解

JVM就是java虚拟机。

内存区域 和 垃圾回收  类加载 三大块



作用

- 运⾏并管理Java 源码⽂件所⽣成的**Class⽂件，**
- 在不同的操作系统上安装不同的JVM，从⽽实现了跨平台的保证。
- 类加载机制：Class文件加载到内存中，要借助Java中的类加载机制
- 垃圾回收机制：通过JVM参数设置 不同垃圾收集器

# 内存区域=运行时数据区

> 针对HotSpot虚拟机
>
> 常见面试题
>
> - 介绍下Java 内存区域(运行时数据区)
> - Java 对象的创建过程(五步，建议能默写出来并且要知道每一步虚拟机做了什么)
> - 对象的访问定位的两种方式(句柄和直接指针两种方式)

> 前言
>
> 对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务



## 内存区域=运行时数据区详解

Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域

参考图

![Java 运行时数据区域（JDK1.7）](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307312250467.png)

![Java 运行时数据区域（JDK1.8 ）](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307312251636.png)

简洁形式：

![image-20230720160631205](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307201606261.png)

运行时数据区域 分为 **PC 本地方法栈 java虚拟机栈 方法区堆**

1.8以前 PC+双栈 线程私有 堆+方法区共享 堆里有字符串常量池 方法区有运行时常量池

1.8以后：方法区变为元空间 放在直接内存中，而不在运行时的数据区域

具体功能

- PC程序计数器：**记忆当前线程执行的位置，**
- 虚拟机栈：方法调用通过栈实现
- 本地方法栈：执行natvie方法 
- 堆：存放对象实例和数组；**垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**、
- 方法区 变为元空间：存放运行时常量池，由Class⽂件常量池所对应的运⾏时常量池、字段和⽅法的元数据信息、类的模板信息等
- 直接内存 并不是JVM运行时数据区的一部分, 但也会被频繁的使用:

字符串常量池：为String设置，避免字符串重复创建



**线程私有**

程序计数器PC

虚拟机栈

本地方法栈

**线程共享**

堆

方法区

直接内存(非运行时数据区的一部分)

---

### PC 程序计数器

作用

- 字节码解释器通过改变程序计数器来依次读取指令，从而**实现代码的流程控制**，如: 顺序执行、选择、循环、异常处理。

- 在多线程的情况下，程序计数器用于**记录当前线程执行的位置**，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

  

> 程序计数器是唯一一个不会出现 outofMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### Java 虚拟机栈

- 线程私有
- 生命周期和线程 相同， 创建和死亡一起
- 除了native方法外，其余方法调用通过栈实现
- 由栈帧组成，压栈出栈
- 栈帧 局部变量表，方法返回地址，动态链接，操作数栈

![Java 虚拟机栈](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051117505.png)

### 本地方法栈

运行native方法

也有栈帧



### 堆

- java管理内存最大一块，所有线程共享
- 存放对象实例和数组
- 堆内存空间划分见GC

#### 为什么用元空间代替永久代

永久代有JVM设置的上限，无法调整。元空间用的本地内存。

### 方法区

- 线程共享
- 

### 运行时常量池

存放各种字面量和符号引用的常量池表

### 字符串常量池

针对String类创建，避免字符串的重复创建。

~~~java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true

~~~



### 直接内存



## 堆和栈有什么区别

**申请方式 内容 效率  空间大小**

（1）申请方式
stack:由**系统自动分配**。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间
heap:需要**程序员自己申请**，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟
（2）申请后系统的响应
stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示**栈溢出**。
heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

（3）申请大小的限制
stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， **堆获得的空间比较灵活，也比较大。**
（4）申请效率的比较
stack：由系统自动分配，速度较快。但程序员是无法控制的。
heap：由 new 分配的内存，一般速度比较慢，而且**容易产生内存碎片,不过用起来最方便。**
（5）heap和stack中的存储内容
stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

## 内存模型

java内存模型和java运行时内存区域不是一个概念

---

Java 内存模型(Java Memory Mode)是一种**规范**，用于描述 Java 虚拟机 （JVM)中多线程情况下，线程之间如何协同工作，如何共享数据，并保证多线程的操作在各个线程之间的可见性、有序性和原子性。

具体定义如下:

- 所有的变量都存储在**主内存(Main Memory)**中。
- 每个线程都有一个**私有的本地内存(Local Memory)**，该私有本地内存中存了该线程以读/写共享变量的**拷贝副本**
- 线程对变量的所有操作都必须在**本地内存**中进行，而不能直接读写主内存。
- 不同的线程之间无法直接访问对方本地内存中的变量，线程间共享变量时，通过**主内存**来实现通信、协作和传递信息。

Java内存模型的抽象图:

![JMM(Java 内存模型)](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191853408.png)

主内存作用存储所有**共享变量**，供线程进行读取

线程从主内存读取x 会在自己的工作内存存储一个x变量副本  

线程a更新x=1 放入主内存  线程b读取主内存x=1 修改为x=2 放入主内存继续供其他线程读取

java是共享内存并发模型， 解决消息同步和线程通信问题

![image-20230717160909189](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191853462.png)

私有的不会有共享问题  栈的变量不会共享 不受到内存模型影响

堆变量有**内存可见性**问题

JMM定义线程和主内存的抽象关系

## 虚拟机栈的结构。执行方法的流程

每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**用于存储**局部变量表、操作数栈、动态链接**、方法出口等信息；

方法调用完成栈帧出栈摧毁

## JVM的运行时数据区，方法区里有啥

方法区变为元空间 有**运行时常量池**；

虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

# 垃圾回收(GC)

> 如果没有特殊说明。都是针对HotSpot虚拟机
>
> 面试题
>
> - 如何判断对象是否死亡(两种方法)
> - 简单的介绍一下强引用、软引用、弱引用、虚引用(虚引用与软引用和弱引用的区别、使用软引用能带来的好处)
> - 如何判断一个常量是废弃常量
> - 如何判断一个类是无用的类
> - 垃圾收集有哪些算法，各自的特点?
> - HotSpot 为什么要分为新生代和老年代?
> - 常见的垃圾回收器有哪些?
> - 介绍一下CMS,G1收集器
> - Minor Gc和 Full GC 有什么不同呢?

## 堆空间的基本内存结构

> **前言** 
>
> Java 的自动内存管理主要是针对对象内存的**回收**和对象内存的**分配**。同时，Java 自动内存管理最**核心**的功能是**堆**内存中对象的分配与回收
>
> Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆 (Garbage Collected Heap)
>
> **堆空间划分原因**
>
> 从垃圾回收的角度来说，由于现在收集器基本都采用**分代垃圾收集**算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。

简要回答：

分为 jdk1.7 和1.8之后  三个区域 以及 永久代移动至直接内存变为元空间

---

在JDK 7 版本及JDK 7 版本之前，堆内存被通常分为下面三部分:
1.新生代内存(Young Generation)：Edge区，两个 Survivor 区 S0和 S1
2.老生代(Old Generation)
3.永久代(Permanent Generation)

JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存。

<img src="https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309042338413.png" alt="堆内存结构" style="zoom: 67%;" />

## 堆内分配与回收策略

### 对象优先在Eden区分配

对象优先在新生代中 Eden 区分配。

当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

执行 Minor GC后，后面分配的对象如果能够存在 Eden 区的话
还是会在Eden 区分配内存。

> 分配满eden区 再分配对象2，发起Minor GC,期间发现对象1无法放入survivor空间，于是通过 **分配担保机制** 转移到老年代。老年代的空间够放对象1，不会 Full GC。

### 大对象直接进入老年代

简答:大对象就是需要大量连续内存空间的对象 (比如: 字符串、数组)

----

大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

- G1垃圾回收器会根据-XX:G1HeapRegionSize参数设置的堆区域大小和-XX:G1MixedGCLiveThresholdPercent参数设置的闯值，来决定哪些对象会直接进入老年代。
- Parallel Scavenge垃圾回收器中，默认情况下，并没有一个固定的闻值(XX:ThresholdTolerance是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定

### 长期存活的对象将进入老年代

既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄 (Age)计数器

大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间 (s0 或者 s1)中，并将对象年龄设为 1(Eden 区>Survivor 区后对象的初始年龄变为 1)。

对象在 Survivor 中每熬过一次 MinorGC,年龄就增加1岁，当它的年龄增加到一定程度(默认为 15 岁)，就会被晋升到老年代中。对象晋升到老年代的年龄闻值，可以通过参数 `-xx:MaxTenuringThreshold` 来设置

### 主要进行gc的区域

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种:
部分收集(Partial GC):

- 新生代收集 (Minor GC /Young GC) : 只对新生代进行垃圾收集;
- 老年代收集(Major GC /Old GC): 只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集;
- 混合收集 (Mixed GC) : 对整个新生代和部分老年代进行垃圾收集

整堆收集(Full GC): 收集整个 Java 堆和方法区

### 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间(Minor GC后可能新生代对象全部进入老年代)

## 判断对象存活的方法=死亡对象判断方法

> 堆中存放对象实例，堆垃圾回收就是回收垃圾对象，第一步就要判断对象是否死亡

两种方法

### 1.**引用计数法**

- 给 对象添加引用计数器， 引用数为0时就说不可能再使用；
- 增加/减少 引用  计数器+1/-1

**问题**

无法解决**循环引用**的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；

### 2.**可达性分析法**

​	从一系列GC ROOT对象作为起点，往下搜索引用链，如果一个对象到GC ROOTs之间没有任何引用链相连的话，说明对象不可用

#### GC-ROOT对象是什么（哪些可以作为GC Root对象？）

- **虚拟机栈(栈帧中的本地变量表)中引用**的对象
- **本地方法栈(Native 方法)中引用**的对象
- **方法区 中 类静态属性**引用的对象
- **方法区 中 常量引用**的对象

### 引用类型总结

强软弱虚四种（引用强度依次减弱

![Java 引用类型总结](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309042359383.png)

1.强引用strong：

- 正常的引用类型
- 垃圾回收器抛出OOM也不会回收	

2.软引用soft：

- 内存空间不够就会回收

3.弱引用weak：

- 垃圾回收器发现弱引用的对象就回收（只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存）
- 区别软引用：软引用空间不够才回收，弱引用被垃圾回收器发现就回收

4.虚引用phantom：和没有引用一样，任何时候都能被回收

## 垃圾收集算法

### 1.标记-清除算法

![标记-清除算法](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051140820.png)

**流程**

​	1标记**需要回收**的对象 

​	2再回收被标记的对象

1利用可达性去遍历内存，把**垃圾对象**进行标记；
2再遍历一遍，将所有标记的对象回收掉；

缺点 

1.效率不高，标记和清除的效率都不高；

2.清理后内存碎片：标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；

### 2.复制算法

​	内存分为大小相同两块，每次用一半内存 ，用完后把还**存活**的复制到另一半，这一半全部清理

![复制算法](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051140063.png)

​	缺点：

1可用内存变小 为原来一半 

2不适合大对象 老年代：存活对象数量比较大，复制性能会很差

​	优点：

没有内存碎片

### 3.标记-整理

​	适合老年代，类似标记清除 但是不是清除 是将存活对象向一端移动，然后直接清理掉端边界外的内存。

![标记-整理算法](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051139886.png)

### 4.分代收集

当前虚拟机都采用分代收集算法，新生代和老年代选择不同的垃圾收集算法。

> 1新生代中，每次收集都会有大量对象死去，所以可以选择"标记-复制"算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。2老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集

## 垃圾收集器

jdk默认垃圾收集器

- JDK 8: Parallel Scavenge (新生代) + Parallel Old (老年代)
- JDK 9 ~JDK20: G1



### Parallel Scavenge收集器





### Parallel Old收集器



### CMS收集器

> stw是stop the world

- CMS是 并发标记清除concurrent Mark Sweep
- 以获取最短回收停顿时间为目标。注重用户体验
- 基于 “标记-清除”算法实现

![CMS 收集器](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051359831.png)

针对标记清除 有什么优化？

并发清除，用户体验较好

**流程**

1初始标记：**STW暂停所有的其他线程**，记录直接与GC ROOT相连的对象，速度很快。

2并发标记：并发（同时开启GC和用户线程）继续向下记录可达对象

3重新标记，**STW**；修正并发标记阶段产生变动的对象标记

4并发清除：清除

**优点** 

1并发收集

2低停顿

**缺点**

​	1.对CPU资源敏感，因为并发回收

​	2.无法处理浮动垃圾；标记和清理阶段 会有新垃圾产生

​	3. 使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生

### G1收集器

![G1 收集器](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309051404870.png)

- G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。

- 按照区域Region回收垃圾

- G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率(把内存化整为零)。

- 从JDK9开始，成为默认的垃圾收集器

  



**流程**

- 初始标记 STW标记GCroot能直接关联到的对象
- 并发标记 对堆中所有对象可达性分析
- 最终标记 STW，处理上个阶段仍有引用变动的对象
- 筛选回收STW，统计Region把要回收的regin的活对象复制到空的Region中，再清理旧Region空间；**操作涉及存活对象的移动**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region**；

### ZGC收集器





## GC（Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC ）

![image-20230825163133690](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202308251631742.png)

新生代有 3 个分区: Eden、To Survivor、From Survivor 

新生代采用**复制**算法

老年代  **标记清理or整理**

eden没空就就MINOR GC

然后放到 from 区

大对象放入老年代

老年代空间不够就full gc

## 老年代的对象引用了年轻代的对象会怎样？

年轻代的对象一般都是存活时间比较短的，而老年代的对象存活时间比较长，老年代的对象引用了年轻代的对象，会导致年轻代的这个对象不容易被垃圾收集器回收，导致该对象存活时间比较长，当这个对象存活年龄达到一定程度后，就会被移动到老年代。

## HotSpot VM 的实现，Partial GC和Full GC

JVM的GC分两类

**Partial GC**

​	Minor GC/Young GC: 只收集young gen的GC

​	Major gc/Old GC: 只收集old gen的GC。只有CMS的concurrent collection是这个模式

​	Mixed GC:收集整个young gen以及部分old gen的GC。只有G1有这个模式

**FULL GC**：收集整个 Java 堆和方法区。

触发条件： eden区满  触发minorGC    full gc 老年代空间不够

# 调优篇

# 类文件结构（Class文件）

# 类加载过程

## 类加载概念和类加载过程

**前言**

自己的java文件要运行要经过**编译**和**类加载**的过程 ；

**一个类的生命周期**

一个类型从被加载到虚拟机内存中开始， 到卸载出内存为止， 它的整个生命周期将会经历
**加载 、 { 验证 、 准备 、解析} 也称连接 、 初始化 、 使用 和 卸载**

>  类加载指的是前面的五步

---

**类加载**是指Class文件需要加载到JVM后才能运行和使用，生成一个Class对象；系统加载Class文件分为五步

- 加载
- 验证
- 准备
- 解析
- 初始化

**类的生命周期**

- 加载：由类加载器完成，内存中生成 类的class对象，
- 验证：验证Class文件符合虚拟机规范
- 准备：**正式为 类变量 分配内存并设置 类变量初始值 **
- 解析：常量池内的**符号引用**替换为**直接引用**
- 初始化：执行初始化方法，这一步JVM真正执行类中定义的Java程序代码。
- 使用 
- 卸载：类的class对象被GC

## **类加载过程详述**

**加载**
用户可介入，可以自定义类加载器，重写 loadClass / findClass

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在堆内存中实例化出代表这个类的 java.lang.Class 对象，通过堆中这个对象作为方法区这个类的各
   种元数据的访问入口

**验证**

> 

- 文件格式验证 验证是否符合 Class 文件格式的规范，允许进入方法区
- 元数据验证 对字节码描述的信息进行语义分析以确保符合 Java 语言规范
- 字节码验证 保证方法执行的安全性，StackMapTable 将字节码验证的类型推导转变为类型检查，JDK6 将校验辅助措施挪到了 Javac 编译器里进行
- 符号引用验证 验证该类是否缺少或者被禁止访问它依赖的某些外部类、 方法、 字段等资源，以确保确保解析行为能正常执行

**准备**

> 简述

为静态变量分配内存并赋初始值 (零值)，final static 在 javac 的时候，字段表集合中会有一个ConstantValue 的属性，那么在准备阶段就会被赋期望的值，其余的会存放在< clinit >中，在类初始化
阶段才会被赋期望值

**解析**

将符号引用被替换为直接引用并对其可访问性进行检查，需要在 getfield，putfield，getstatic，
putstatic 等指令之前执行 解析主要针对 类或接口、 字段、 类方法
符号引用 以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可

直接引用 直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄，引用的目标必定已经在虚拟机的内存中存在



**类或接口的解析**

如果被解析的类或接口不是数组类型，那虚拟机会把全限定名传递给当前代码的类加载器去加载，
在加载过程中，可能触发其他类或接口的加载动作，一旦有任何异常，就宣告失败
如果类或接口是数组类型，并且数组的元素类型为对象，那将会按照第一点的规则加载数组元素类
型，接着由虚拟机生成一个代表该数组维度和元素的数组对象
若上面没有异常，则进行符号引用验证，确认当前代码对其的访问权限，没权限
java.lang.IllegalAccessError
**字段解析**
会先对字段所属的类或接口解析，成功后才进行字段解析
如果类或接口本身包含了简单名称和字段描述符都与目标匹配的字段，返回直接引用
如果实现了接口，从下往上递归搜索，看各个接口与父接口是否有简单名称和字段描述符都匹配的字段
如果不是 Object，从下往上递归搜索，看父类中否存在
否则，抛出 java.lang.NoSuchFieldError 异常
查找成功，验证访问权限
**类方法解析**
会先对方法所属的类解析，成功后进行方法解析
本来是解析类方法，如果方法是接口方法则会抛出 java.lang.IncompatibleClassChangeError
如果类本身就就包含了简单名称和字段描述符都与目标匹配的方法直接返回
查找父类、查找接口 、抛出 java.lang.NoSuchMethodError
验证访问权限
**接口方法解析**
会先对方法所属的接口解析，成功后进行方法解析
本来是解析接口方法，如果方法是类方法则会抛出 java.lang.IncompatibleClassChangeError
在接口中查找、查询父接口、抛出java.lang.NoSuchMethodError
验证访问权限
**初始化**
执行类构造器 < clinit > 方法 它是由类变量赋值和 static 语句块构成，执行时父类的< clinit > 一定已经执行完毕，接口实现类初始化时候不会执行父类的 < clinit >

**立即进行初始化**
也叫主动引用 有且只有下面这几种情况
遇到 new、 getstatic/putstatic 或 invokestatic 这四条字节码指令时；（被final修饰、 已在编译
期把结果放入常量池的静态字段除外）
使用 java.lang.reflect 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要
先触发其初化
当初始化类的时候， 如果发现其父类还没有进行过初始化， 则需要先触发其父类的初始化，但是
对于接口是用到其父接口的时候才会初始化其父接口
当虚拟机启动时， 用户需要指定一个要执行的主类（ 包含main()方法的那个类） ， 虚拟机会先初
始化这个主类
当一个接口中定义了JDK 8 新加入的默认方法 (被default关键字修饰的接口方法）时，如果有这个
接口的实现类发生了初始化， 那该接口要在其之前被初始化
被动引用
被动引用不会触发初始化
父类的静态字段 value，SubClass.value 只会触发父类初始化
创建一个对象数组，并不会触发该对象初始化，对象数组的对象类型是由JVM自动生成的一个继承
Object 的子类的类型，创建动作由 newarray 字节码指令触发
访问未初始化类中的常量，编译阶段通过常量传播优化，已经存储在访问类的常量池中了，访问也
是访问的常量池中的常量
数组如何创建
数组的元素类型为对象，会加载数组类型元素，接着由虚拟机生成一个代表该数组维度和元素的数
组对象



# 类加载器



类加载器作用

- 实现类的加载
- 同类一起确立在 Java虚拟机中的唯一性，只有相同类加载器加载的类才是相同的
  类

## 类加载器是什么

作用:**加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

分为四种

- 启动类加载器：核心类库
- 扩展类加载器：扩展类
- 应用程序类加载器
- 自定义加载器

<img src="https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191557612.png" alt="image-20230719155749511" style="zoom:50%;" />

## 双亲委派模型

### 概念

决定加载一个类的时候具体由哪个类加载器加载

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

**好处：**

核心类库不会被破坏，自己写的JAVA.lang.string就不会覆盖string类

避免重复加载

### 如何打破双亲委派模型

自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。

# JVM参数=调优篇

**调优目的**

GC调优目的：GC时间够少, GC次数够少
minor GC 单次耗时 < 50ms，频率10秒以上。说明年轻代OK
Full GC 单次耗时< 1秒，频率10分钟以上，说明年老代OK

**参数**

-XX:+PrintGCDetails





1. -Xms 5m设置JVM初始堆为5M，-Xmx 5m 设置JVM最大堆为5M。-Xms跟-Xmx值一样时可以避免
   每次垃圾回收完成后JVM重新分配内存
2. -Xmn 2g:设置年轻代大小为2G，一般默认为整个堆区的1/3 ~ 1/4。-Xss每个线程栈空间设置
3. -XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值，默认=8，比值为8:1:1
4. -XX:+HeapDumpOnOutOfMemoryError** 当JVM发生OOM时，自动生成DUMP文件
5. -XX:PretenureSizeThreshold 当创建的对象超过指定大小时，直接把对象分配在老年代。
6. -XX:MaxTenuringThreshold 设定对象在Survivor区最大年龄阈值，超过阈值转移到老年代，默认
   15
7. 开启GC日志对性能影响很小且能帮助我们定位问题
   -XX:+PrintGCTimeStamps - XX:+PrintGCDetails -Xloggc:gc.log 日志位置

# 性能监控故障处理

![image-20230904225113415](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202309042251488.png)

