# 日常实习-JVM面试题

8.描述一下JVM？我就说了一下Java内存区域。
9.问我了不了解 GC，说一下相关算法？我就记起来标记复制和标记整理了，标记复制还说成了标记清除哈哈。

5.JVM垃圾回收（感觉没说全，我这种垃圾就该被回收呜呜呜）

8.HotSpot VM 的实现，Partial GC和Full GC

9.双亲委派模型

10.java内存模型

# 基础

## 讲一下JVM（聊一下你对JVM的理解

# JVM内存区域

JVM就是java虚拟机。

作用

- 运⾏并管理Java 源码⽂件所⽣成的**Class⽂件，**
- 在不同的操作系统上安装不同的JVM，从⽽实现了跨平台的保证。
- 类加载机制：Class文件加载到内存中，要借助Java中的类加载机制
- 垃圾回收机制：通过JVM参数设置 不同垃圾收集器





## 讲一下JVM的内存区域，运行时数据区

![Java 运行时数据区域（JDK1.7）](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307312250467.png)

![Java 运行时数据区域（JDK1.8 ）](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307312251636.png)

简洁形式：

![image-20230720160631205](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307201606261.png)

运行时数据区域 分为 **PC 本地方法栈 java虚拟机栈 方法区堆**

1.8以前 PC+双栈 线程私有 堆+方法区共享 堆里有字符串常量池 方法区有运行时常量池

1.8以后：方法区变为元空间 放在直接内存中，而不在运行时的数据区域

具体功能

- PC程序计数器：**记忆当前线程执行的位置，**
- 虚拟机栈：方法调用通过栈实现
- 本地方法栈：执行natvie方法 
- 堆：存放对象实例和数组；**垃圾收集器管理的主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**、
- 方法区 变为元空间：存放运行时常量池，由Class⽂件常量池所对应的运⾏时常量池、字段和⽅法的元数据信息、类的模板信息等
- 直接内存 并不是JVM运行时数据区的一部分, 但也会被频繁的使用:

字符串常量池：为String设置，避免字符串重复创建

## 堆和栈有什么区别

**申请方式 内容 效率  空间大小**

（1）申请方式
stack:由**系统自动分配**。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间
heap:需要**程序员自己申请**，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟
（2）申请后系统的响应
stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示**栈溢出**。
heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

（3）申请大小的限制
stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， **堆获得的空间比较灵活，也比较大。**
（4）申请效率的比较
stack：由系统自动分配，速度较快。但程序员是无法控制的。
heap：由 new 分配的内存，一般速度比较慢，而且**容易产生内存碎片,不过用起来最方便。**
（5）heap和stack中的存储内容
stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

## 内存模型

java内存模型和java运行时内存区域不是一个概念

---

Java 内存模型(Java Memory Mode)是一种**规范**，用于描述 Java 虚拟机 （JVM)中多线程情况下，线程之间如何协同工作，如何共享数据，并保证多线程的操作在各个线程之间的可见性、有序性和原子性。

具体定义如下:

- 所有的变量都存储在**主内存(Main Memory)**中。
- 每个线程都有一个**私有的本地内存(Local Memory)**，该私有本地内存中存了该线程以读/写共享变量的**拷贝副本**
- 线程对变量的所有操作都必须在**本地内存**中进行，而不能直接读写主内存。
- 不同的线程之间无法直接访问对方本地内存中的变量，线程间共享变量时，通过**主内存**来实现通信、协作和传递信息。

Java内存模型的抽象图:

![JMM(Java 内存模型)](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191853408.png)

主内存作用存储所有**共享变量**，供线程进行读取

线程从主内存读取x 会在自己的工作内存存储一个x变量副本  

线程a更新x=1 放入主内存  线程b读取主内存x=1 修改为x=2 放入主内存继续供其他线程读取

java是共享内存并发模型， 解决消息同步和线程通信问题

![image-20230717160909189](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191853462.png)

私有的不会有共享问题  栈的变量不会共享 不受到内存模型影响

堆变量有**内存可见性**问题

JMM定义线程和主内存的抽象关系

## 虚拟机栈的结构。执行方法的流程

每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**用于存储**局部变量表、操作数栈、动态链接**、方法出口等信息；

方法调用完成栈帧出栈摧毁

## JVM的运行时数据区，方法区里有啥

方法区变为元空间 有**运行时常量池**；

虚拟机加载的 **类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据**。

# GC 垃圾回收

## 堆空间内存结构

![image-20230719171358881](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191713918.png)

1.8后 永久代变为元空间放在直接内存中

## 判断对象存活的方法（死亡对象判断方法）

两种方法

1.**引用计数法**

​	给 对象添加引用计数器， 引用数为0时就说不可能再使用，

​	问题：无法解决**循环引用**的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；

2.**可达性分析法**

​	从一系列GC ROOT对象作为起点往下搜索引用链，如果一个对象到GC ROOTs之间没有任何引用链相连的话 说明对象不可用

## GC-ROOT对象是什么（哪些可以作为GC Root对象？

- **虚拟机栈(栈帧中的本地变量表)中引用**的对象
- **本地方法栈(Native 方法)中引用**的对象
- **方法区 中 类静态属性**引用的对象
- **方法区 中 常量引用**的对象

## JVM的垃圾回收机制

## GC（Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC ）

![image-20230825163133690](https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202308251631742.png)

新生代有 3 个分区: Eden、To Survivor、From Survivor 

新生代采用**复制**算法

老年代  **标记清理or整理**

eden没空就就MINOR GC

然后放到 from 区

大对象放入老年代

老年代空间不够就full gc

## 老年代的对象引用了年轻代的对象会怎样？

年轻代的对象一般都是存活时间比较短的，而老年代的对象存活时间比较长，老年代的对象引用了年轻代的对象，会导致年轻代的这个对象不容易被垃圾收集器回收，导致该对象存活时间比较长，当这个对象存活年龄达到一定程度后，就会被移动到老年代。

## HotSpot VM 的实现，Partial GC和Full GC

JVM的GC分两类

**Partial GC**

​	Minor GC/Young GC: 只收集young gen的GC

​	Major gc/Old GC: 只收集old gen的GC。只有CMS的concurrent collection是这个模式

​	Mixed GC:收集整个young gen以及部分old gen的GC。只有G1有这个模式

**FULL GC**：收集整个 Java 堆和方法区。

触发条件： eden区满  触发minorGC    full gc 老年代空间不够

## --介绍下空间分配担保原则



## 了不了解GC 说一下相关算法 

1.标记-清除

​	两个阶段 标记**不需要回收**的对象 再回收没有被标记的对象

​	缺点 1.效率不高 2.内存碎片

2.复制

​	每次用一半内存 ，用完后把还**存活**的复制到另一半，这一半全部清理

​	缺点：1可用内存变小 2不适合大对象 老年代

​	优点：没有内存碎片

3.标记-整理

​	适合老年代，类似标记清除 但是不是清除 是将存活对象向一端移动，然后直接清理掉端边界外的内存。

4.分代收集

## 你常用的jvm垃圾收集算法是什么，说说垃圾对象从标记到清理的整个流程

标记清除

第一步：利用可达性去遍历内存，把**存活对象和垃圾对象**进行标记；
第二步：在遍历一遍，将所有标记的对象回收掉；
特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；

## 垃圾回收器

CMS

G1

## 讲一下CMS，标记清除算法的缺点？针对该问题CMS有做什么优化吗？

> stw是stop the world

CMS是 并发标记清除concurrent Mark Sweep



标记-清除算法实现

1初始标记**STW**，从GCROOT开始

2并发标记，继续向下 多线程

3重新标记，**STW**；在标记一次

4并发清除：删除已经死亡对象

**优点** 

并发收集、低停顿

**缺点**

​	1.对CPU资源敏感 因为并发回收

​	2.无法处理浮动垃圾；标记和清理阶段 会有新垃圾产生

​	3. 大量空间碎片

## 了解G1垃圾回收器吗，它的垃圾回收策略

​	G1 从整体来看是基于“标记-整理”算法实现的收集器；

​		从局部上来看是基于“标记-复制”算法实现的。

按照区域Region回收垃圾

g1 分为四个步骤

- 初始标记 STW标记GCroot能直接关联到的对象
- 并发标记 对堆中所有对象可达性分析
- 最终标记 STW，处理上个阶段仍有引用变动的对象
- 筛选回收STW，统计Region把要回收的regin的活对象复制到空的Region中，在清理旧Region空间；操作涉及存活对象的移动

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region**；

# 类加载

## 什么是类加载？类加载的一个过程？

自己的java文件要运行要经过**编译**和**类加载**的过程 

**类加载**是指Class文件需要加载到JVM后才能运行和使用，生成一个Class对象；系统加载Class文件分为五步

- 加载
- 验证
- 准备
- 解析
- 初始化

类的生命周期

- 加载：由类加载器完成，内存中生成 类的class对象，
- 验证：验证Class文件符合虚拟机规范
- 准备：**正式为 类变量 分配内存并设置 类变量初始值 **
- 解析：常量池内的**符号引用**替换为**直接引用**
- 初始化：执行初始化方法
- 使用 
- 卸载：类的class对象被GC

## 类加载的初始化做什么

调用类的构造器

## 类加载器是什么

作用:**加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。**

分为四种

- 启动类加载器：核心类库
- 扩展类加载器：扩展类
- 应用程序类加载器
- 自定义加载器

<img src="https://duoduo-img.oss-cn-shenzhen.aliyuncs.com/202307191557612.png" alt="image-20230719155749511" style="zoom:50%;" />

## 什么是双亲委派模型

决定加载一个类的时候具体由哪个类加载器加载

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

**好处：**

核心类库不会被破坏，自己写的JAVA.lang.string就不会覆盖string类

避免重复加载

## 什么情况打破双亲委派

自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。

# 创建对象的方式。

 (说了四种，new、反射、序列化和反序列化、克隆)



# 7、深拷贝、浅拷贝区别。

区别在拷贝对象时：

浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是**引用类型的话，浅拷贝会直接复制内部对象的引用地址**

深拷贝**创建新的内部对象**

